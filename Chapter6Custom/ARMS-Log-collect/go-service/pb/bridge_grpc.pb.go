// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.4
// source: bridge/v1/bridge.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JavaBridge_ValidateUser_FullMethodName     = "/bridge.v1.JavaBridge/ValidateUser"
	JavaBridge_ReserveInventory_FullMethodName = "/bridge.v1.JavaBridge/ReserveInventory"
	JavaBridge_AuditOrder_FullMethodName       = "/bridge.v1.JavaBridge/AuditOrder"
)

// JavaBridgeClient is the client API for JavaBridge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JavaBridgeClient interface {
	ValidateUser(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
	ReserveInventory(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
	AuditOrder(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
}

type javaBridgeClient struct {
	cc grpc.ClientConnInterface
}

func NewJavaBridgeClient(cc grpc.ClientConnInterface) JavaBridgeClient {
	return &javaBridgeClient{cc}
}

func (c *javaBridgeClient) ValidateUser(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, JavaBridge_ValidateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *javaBridgeClient) ReserveInventory(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, JavaBridge_ReserveInventory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *javaBridgeClient) AuditOrder(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, JavaBridge_AuditOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JavaBridgeServer is the server API for JavaBridge service.
// All implementations must embed UnimplementedJavaBridgeServer
// for forward compatibility.
type JavaBridgeServer interface {
	ValidateUser(context.Context, *ActionRequest) (*ActionReply, error)
	ReserveInventory(context.Context, *ActionRequest) (*ActionReply, error)
	AuditOrder(context.Context, *ActionRequest) (*ActionReply, error)
	mustEmbedUnimplementedJavaBridgeServer()
}

// UnimplementedJavaBridgeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJavaBridgeServer struct{}

func (UnimplementedJavaBridgeServer) ValidateUser(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateUser not implemented")
}
func (UnimplementedJavaBridgeServer) ReserveInventory(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method ReserveInventory not implemented")
}
func (UnimplementedJavaBridgeServer) AuditOrder(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method AuditOrder not implemented")
}
func (UnimplementedJavaBridgeServer) mustEmbedUnimplementedJavaBridgeServer() {}
func (UnimplementedJavaBridgeServer) testEmbeddedByValue()                    {}

// UnsafeJavaBridgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JavaBridgeServer will
// result in compilation errors.
type UnsafeJavaBridgeServer interface {
	mustEmbedUnimplementedJavaBridgeServer()
}

func RegisterJavaBridgeServer(s grpc.ServiceRegistrar, srv JavaBridgeServer) {
	// If the following call panics, it indicates UnimplementedJavaBridgeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JavaBridge_ServiceDesc, srv)
}

func _JavaBridge_ValidateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JavaBridgeServer).ValidateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JavaBridge_ValidateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JavaBridgeServer).ValidateUser(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JavaBridge_ReserveInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JavaBridgeServer).ReserveInventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JavaBridge_ReserveInventory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JavaBridgeServer).ReserveInventory(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JavaBridge_AuditOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JavaBridgeServer).AuditOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JavaBridge_AuditOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JavaBridgeServer).AuditOrder(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JavaBridge_ServiceDesc is the grpc.ServiceDesc for JavaBridge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JavaBridge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bridge.v1.JavaBridge",
	HandlerType: (*JavaBridgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateUser",
			Handler:    _JavaBridge_ValidateUser_Handler,
		},
		{
			MethodName: "ReserveInventory",
			Handler:    _JavaBridge_ReserveInventory_Handler,
		},
		{
			MethodName: "AuditOrder",
			Handler:    _JavaBridge_AuditOrder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bridge/v1/bridge.proto",
}

const (
	GoBridge_ProcessPayment_FullMethodName = "/bridge.v1.GoBridge/ProcessPayment"
	GoBridge_IssueRefund_FullMethodName    = "/bridge.v1.GoBridge/IssueRefund"
	GoBridge_QueryPayment_FullMethodName   = "/bridge.v1.GoBridge/QueryPayment"
)

// GoBridgeClient is the client API for GoBridge service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoBridgeClient interface {
	ProcessPayment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
	IssueRefund(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
	QueryPayment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error)
}

type goBridgeClient struct {
	cc grpc.ClientConnInterface
}

func NewGoBridgeClient(cc grpc.ClientConnInterface) GoBridgeClient {
	return &goBridgeClient{cc}
}

func (c *goBridgeClient) ProcessPayment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, GoBridge_ProcessPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goBridgeClient) IssueRefund(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, GoBridge_IssueRefund_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goBridgeClient) QueryPayment(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActionReply)
	err := c.cc.Invoke(ctx, GoBridge_QueryPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoBridgeServer is the server API for GoBridge service.
// All implementations must embed UnimplementedGoBridgeServer
// for forward compatibility.
type GoBridgeServer interface {
	ProcessPayment(context.Context, *ActionRequest) (*ActionReply, error)
	IssueRefund(context.Context, *ActionRequest) (*ActionReply, error)
	QueryPayment(context.Context, *ActionRequest) (*ActionReply, error)
	mustEmbedUnimplementedGoBridgeServer()
}

// UnimplementedGoBridgeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGoBridgeServer struct{}

func (UnimplementedGoBridgeServer) ProcessPayment(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method ProcessPayment not implemented")
}
func (UnimplementedGoBridgeServer) IssueRefund(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method IssueRefund not implemented")
}
func (UnimplementedGoBridgeServer) QueryPayment(context.Context, *ActionRequest) (*ActionReply, error) {
	return nil, status.Error(codes.Unimplemented, "method QueryPayment not implemented")
}
func (UnimplementedGoBridgeServer) mustEmbedUnimplementedGoBridgeServer() {}
func (UnimplementedGoBridgeServer) testEmbeddedByValue()                  {}

// UnsafeGoBridgeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoBridgeServer will
// result in compilation errors.
type UnsafeGoBridgeServer interface {
	mustEmbedUnimplementedGoBridgeServer()
}

func RegisterGoBridgeServer(s grpc.ServiceRegistrar, srv GoBridgeServer) {
	// If the following call panics, it indicates UnimplementedGoBridgeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GoBridge_ServiceDesc, srv)
}

func _GoBridge_ProcessPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoBridgeServer).ProcessPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoBridge_ProcessPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoBridgeServer).ProcessPayment(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoBridge_IssueRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoBridgeServer).IssueRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoBridge_IssueRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoBridgeServer).IssueRefund(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoBridge_QueryPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoBridgeServer).QueryPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoBridge_QueryPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoBridgeServer).QueryPayment(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GoBridge_ServiceDesc is the grpc.ServiceDesc for GoBridge service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GoBridge_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bridge.v1.GoBridge",
	HandlerType: (*GoBridgeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessPayment",
			Handler:    _GoBridge_ProcessPayment_Handler,
		},
		{
			MethodName: "IssueRefund",
			Handler:    _GoBridge_IssueRefund_Handler,
		},
		{
			MethodName: "QueryPayment",
			Handler:    _GoBridge_QueryPayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bridge/v1/bridge.proto",
}
